// Оператор Spread (также называют оператором расширения)
// Позволяет расширить доступные для итерации элементы
// Пишется с помощью трёх точек: ...

// Представим, что есть 2 массива, из которых мы хотим создать один цельный массив
const regular = ['VW', 'Skoda', 'Audi'];
const electric = ['Tesla', 'Bmw', 'Jaguar'];

// мы можем это сделать стандартным способом, т.е. склеить их при помощи метода concat()
const cars = regular.concat(electric);
// можем увидеть, что в принципе у нас это получилось и без каких либо операторов
console.log(cars);

// Но, что если например потребуется между этими двумя массивами добавить еще один элемент?

// теоретически это можно сделать, создав переменную при помощи let и каждый раз обновлять значение переменной
let cars2 = [];
cars2 = cars2.concat(regular);
cars2.push('Mercedes');
cars2 = cars2.concat(electric);
// можно увидеть, что у нас это получилось, но не совсем удобно писать именно так.
console.log(cars2);

// теперь попробуем с оператором Spread (...)
const cars3 = [...regular, 'Mercedes', ...electric];
// в результате, мы сделали то же самое, но с очень удобным и хорошо читаемым синтаксисом
console.log(cars3);

// При помощи оператора Spread можно объединить массивы и строки в один массив

// Также с помощью оператора Spread мы можем скопировать массив

// Давайте посмотрим, как копировались массивы раньше
// создадим новую переменную и присвоим ей значение массива cars3
const carsNew = cars3;
// Видим, что у нас это вроде бы получилось, массивы в обоих переменных одинаковы
// console.log(cars3);
// console.log(carsNew);

// Но что будет, если мы изменим первый элемент в массиве carsNew (предыдущие console комментируем)
carsNew[0] = 'GM';
// Мы увидем, что первый элемент поменяется в обоих массивах
console.log(cars3);
console.log(carsNew);

// почему так происходит? на самом деле мы не создаем копию массива, а передаем ссылку на предыдущий, и получается, что теперь к нему можно обращаться при помощи двух переменных

// А как создать копию?
// Можно создать пустой массив, и склеить его с предыдущим массивом

const carsNew2 = [].concat(cars)
carsNew2[0] = 'Volvo';
console.log(cars3);
console.log(carsNew2);

// теперь все вроде работает, копия массива создана, но опять же не очень удобный способ

// Теперь, как это можно сделать оператором Spread

const carsNew3 = [...cars3];
carsNew3[0] = 'Audi';
console.log(cars3);
console.log(carsNew3);

// также видим, что копия массива успешно создана, а старый никак не затронут


// теперь попробуем использовать оператор Spread со строковым выражением

const word = 'Audi';
const letters = [...word];
console.log(letters);

// теперь видим, что каждое слово нашей переменной word используется как отдельный элемент в массиве letters

// как еще мы можем использовать оператор Spread?
// создадим несколько элементов в HTML и получим их при помощи querySelectorAll. Также создадим второй массив, и попробуем их склеить при помощи concat();

// const cars4 = document.querySelectorAll('.cars span');
// console.log(cars4);
// const cars5 = [1,2,3];
// const autos = cars4.concat(cars5);
// console.log(autos);

// у нас вышла ошибка, так как при помощи querySelectorAll мы получем не массив, а NodeList (коллекцию). А метод concat() работает только с массивами.

// при помощи оператора Spread мы можем превратить NodeList в обычный массив

const cars4 = [...document.querySelectorAll('.cars span')];
console.log(cars4);
const cars5 = [1,2,3];
const autos = cars4.concat(cars5);
console.log(autos);

// теперь все работает

// Оператор REST (...)
// Визуально, оператор REST (...) три точки, похож на оператор spread, но выполняет противоположную функцию.

// Если spread берет элемент из массива и распаковывает или вливает их по одному в другой массив. То rest наоборот берет нужные элементы и запаковывает их в новый массив

// есть 2 типа задач, где оператор rest используется чаще всего - в функциях и в процессе деструктуризации

// Давайте рассмотрим пару примеров использования rest

// Оператор rest в функциях.

// создадим функцию, которая будет конвертировать деньги
// 1й аргумент это текущий курс, а дальше суммы, которые мы хотим поменять
function convert(rate, sum1, sum2, sum3){
    // чтобы произвести какие то вычисления с каждым аргументом функции, придется обращаться к ним по отдельности, что вызовет большое количество повторяющегося кода. Например
    // sum1 / rate
    // sum2 / rate и т.д.
    // Сделаем это при помощи оператора rest ниже
}
// запустим функцию, запишем текущий курс в первом параметре, остальное суммы, которые мы собираемся поменять на доллары
convert(11000, 805600, 8526547, 1000000);

// с оператором rest. вместо аргументов для суммы, мы запишем один аргумент, но с оператором rest (...)
function convert2(rate, ...sums){
    // для проверки выведим в консоль
    console.log(rate, sums);
    // теперь можно при помощи цикла, метода forEach или метода map пробежаться по каждому элементу массива и сделать какие то вычисления
    return sums.map(sum => sum / rate)
    
    // метод map вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции (покажите пару примеров с методом map)
}

// все аргументы, начиная со второго, теперь будут складываться в один массив аргумента ...sums
convert2(11000, 805600, 8526547, 1000000);

// и выведем в консоль результат
console.log(convert2(11000, 805600, 8526547, 1000000));

// Деструктуризация

// Деструктуризация позволяет получить значения нужных элементов из массива или нужных свойств из объекта и присвоить их новым переменным 

// Деструктуризация — это синтаксис, который позволяет распаковывать значения из массивов или свойства из объектов в переменные.

// Что нам это дает? Возможность писать более чистый и понятный код, экономя время и количество строк.

// например

const auto = {
    name: 'tesla',
    year: 2020,
    color: 'white'
}

// предположим, что каждое из этих свойств необходимо присвоить новым переменным. Как бы мы могли сделать это раньше. Нам пришлось бы создать по отдельности 3 переменные

// const name = auto.name;
// const year = auto.year;
// const color = auto.color;

// это не совсем удобно, и занимает больше строк кода

// используя деструктуризацию, можно сделать это проще
// в фигурных скобках, указываем названия свойств, которые мы хотим получить с объекта, и создадутся новые переменные с такими же названиями.
const {name, year, color} = auto;
console.log(name, year, color);

// деструктуризация работает также с любой вложенностью свойств в объектах

const auto2 = {
    name: 'tesla',
    year: 2020,
    color: 'white',
    size: {
        width: '1.3m',
        length: '2.4m'
    }
}

const {width, length} = auto2.size;
console.log(width, length);

// Иногда бывают ситуации когда в процессе деструктуризации нам нужно переименовать нашу переменную, по тем причинам, что ранее мы создавали переменную с таким названием 

// к примеру, мы хотим создать переменные name, year, color только теперь для объекта auto2

// const {name, year, color} = auto2;

// можем заметить, что скрипт выдает нам ошибку, так как ранее мы создавали переменные с таким названием

// сразу писать название новых переменных мы не можем, это будет ошибкой
// const {carName, carYear, carColor} = auto2;

// решить это можно следующим образом

const {name: carName, year: carYear, color: carColor} = auto2;
// т.е. можно написать название нашего свойства, поставить двоеточие, и записать новое название для переменной

console.log(carName, carYear, carColor);

// также мы можем устанавливать значения по умолчанию для наших переменных, которые мы получаем во время деструктуризации. Например

const phone = {
    brand: 'Apple',
    cost: 1000,
    from: undefined
}
// Если если в свойстве находится значениче undefined либо такое свойство отстутствует в объекте, будет выводиться значение по умолчанию которое мы присваиваем к этой переменной в деструктуризации.
const {brand, cost, from = 'USA'} = phone;
console.log(brand, cost, from);

// теперь рассмотрим деструктуризацию с массивами
// запишем 3 свойства, название, год выпуска, цвет
const laptop = ['HP', 2022, 'silver'];
// раньше пришлось бы под каждый элемент создавать переменную
// const laptopName = laptop[0]
// const laptopYear = laptop[1]
// const laptopColor = laptop[2]

// с деструктуризацией

const [laptopName, laptopYear, laptopColor] = laptop;
// название для переменных с массивами можно использовать любые, в отличии от объектов, где названия переменных должны совпадать с названиями свойств
console.log(laptopName, laptopYear, laptopColor);


